<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<script type="text/javascript" src="http://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
<script type="text/javascript" src="http://static.robotwebtools.org/roslibjs/current/roslib.min.js"></script>

<style>
    body{
      margin:0;
      background: #eee;
    }
    #canvas{
      width:640px;
      height:360px;
      background: #fff;
    }
</style>

</head>

<body>
  <h1>F1/10 Web Interface</h1>

  Car IP Address: <input type="text" id="ipaddr" value="localhost">
  <input type="button" onclick="connect()" value="Connect"><br>
  Status: <label id="status">Unknown</label><br>
  <canvas id="canvas" width="640" height="360" tabindex="0"> </canvas>
  <br>
  <label id="coords">0,0</label>


<script type="text/javascript" type="text/javascript">

var ros = undefined;
var scale = 100;
var origin = {x: 0, y: 0};
var prev_origin = {x: 0, y: 0};
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var mouseDownLoc;
var mouseDown = false;
var setLocation = false;
var setNavTarget = false;
var coords = document.getElementById("coords");
var initialposePublisher;
var initialPose = new ROSLIB.Message({
  header: {
    seq: 0,
    stamp: Date.now(),
    frame_id: "map"
  },
  pose: {
    pose: {
      position: {
        x: 0,
        y: 0,
        z: 0
      },
      orientation: {
        x: 0,
        y: 0,
        z: 0,
        w: 1
      }
    },
    covariance: [
      1, 0, 0, 0, 0, 0,
      0, 1, 0, 0, 0, 0,
      0, 0, 1, 0, 0, 0,
      0, 0, 0, 1, 0, 0,
      0, 0, 0, 0, 1, 0,
      0, 0, 0, 0, 0, 1
    ]
  }
});

if (window.localStorage.getItem('ipaddr')) {
  document.getElementById('ipaddr').value = 
      window.localStorage.getItem('ipaddr');
}
canvas.addEventListener('wheel', onMouseScroll, false);
window.addEventListener("keypress", onKeyPress, false );
canvas.onmouseup = onMouseUp;
canvas.onmousedown = onMouseDown;
canvas.onmousemove = onMouseMove;

// Get the "true" mouse location, compensting for scroll, zoom, etc.
function getMouseLocation(event, element) {
  var posx = 0;
  var posy = 0;
  if (!event) var event = window.event;
  if (event.pageX || event.pageY)   {
    posx = event.pageX;
    posy = event.pageY;
  } else if (event.clientX || event.clientY)  {
    posx = event.clientX + document.body.scrollLeft
      + document.documentElement.scrollLeft;
    posy = event.clientY + document.body.scrollTop
      + document.documentElement.scrollTop;
  }
  if (element != undefined &&
      isFinite(element.offsetLeft) &&
      isFinite(element.offsetTop)) {
    posx -= element.offsetLeft;
    posy -= element.offsetTop;
  }
  return ({x:posx, y:posy});
}

function canvasToWorld(p) {
  return {
    x: (p.x - origin.x) / scale,
    y: (origin.y - p.y) / scale
  };
}

function worldToCanvas(p) {
  return {
    x: p.x * scale + origin.x,
    y: origin.y - p.y * scale
  };
}

function onMouseMove(event){
  loc = getMouseLocation(event, canvas);
  w = canvasToWorld(loc);
  const x_str = w.x.toFixed(3);
  const y_str = w.y.toFixed(3);
  coords.innerHTML = `x=${x_str}, y=${y_str}`;
  if (!mouseDown) return;
  if (setLocation || setNavTarget) return;
  origin.x = prev_origin.x + loc.x - mouseDownLoc.x;
  origin.y = prev_origin.y + loc.y - mouseDownLoc.y;
};

function onMouseDown(event){
  mouseDownLoc = getMouseLocation(event, canvas);
  mouseDown = true;
  prev_origin = {x: origin.x, y:origin.y};
  if (event.ctrlKey) {
    setNavTarget = true;
  } else if (event.shiftKey) {
    setLocation = true;
  }
};

function onMouseUp(event){
  loc = getMouseLocation(event, canvas);
  if (setNavTarget) {
    // Set nav target here.
  } else if (setLocation) {
    // Set localization here.
    w = canvasToWorld(loc);
    initialPose.header.seq++;
    initialPose.pose.pose.position.x = w.x;
    initialPose.pose.pose.position.y = w.y;
    a = Math.atan2(mouseDownLoc.y - loc.y, loc.x - mouseDownLoc.x);
    initialPose.pose.pose.orientation.w = Math.cos(0.5 * a);
    initialPose.pose.pose.orientation.z = Math.sin(0.5 * a);
    initialposePublisher.publish(initialPose);
  } else {
    // Pan.
    origin.x = prev_origin.x + loc.x - mouseDownLoc.x;
    origin.y = prev_origin.y + loc.y - mouseDownLoc.y;
    prev_origin = origin;
  }
  setNavTarget = false;
  setLocation = false;
  mouseDown = false;
}

function onMouseScroll(event) {
  if (event.deltaY > 0) {
    scale *= 0.95;
  } else if (event.deltaY < 0) {
    scale *= 1.05;
  }
  return false; 
}


function onKeyPress(event) {
  console.log("Pressed: " + event.which);
};

function drawPoint(color, x, y) {
  ctx.fillStyle = color;
  const p = worldToCanvas({x:x, y:y});
  ctx.fillRect(p.x, p.y, 2, 2);
}

function drawLine(color, x1, y1, x2, y2) {
  ctx.strokeStyle = color;
  ctx.beginPath();
  const p1 = worldToCanvas({x: x1, y:y1});
  const p2 = worldToCanvas({x: x2, y:y2});
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

function updateStatus(str) {
  let s = document.getElementById("status");
  s.innerHTML = str;
}
function main(ipaddr) {
    try {
      ros = new ROSLIB.Ros({
      url : 'ws://' + ipaddr + ':9090'
      });
    } catch(e) {
      updateStatus('ERROR: ' + e.toString());
      return;
    }

    ros.on('connection', function() {
      updateStatus('Connected to websocket server.');
      window.localStorage.setItem('ipaddr', ipaddr);
      initialposePublisher = new ROSLIB.Topic({
        ros : ros,
        name : '/initialpose',
        messageType : 'geometry_msgs/PoseWithCovarianceStamped'
      });
    });

    ros.on('error', function(error) {
      updateStatus('Error connecting to websocket server: ', error);
    });

    ros.on('close', function() {
      updateStatus('Connection to websocket server closed.');
    });
}

function connect() {
  let ipaddr = document.getElementById('ipaddr').value;
  main(ipaddr)
  var listener = new ROSLIB.Topic({
    ros : ros,
    name : '/scan',
    messageType : 'sensor_msgs/LaserScan'
  });

  listener.subscribe(function(message) {
    if (false) {
      updateStatus('Received message on ' + listener.name + ': ' +
          Date.now().toString());
    }
    drawScan(message);
  });
}

// // Publishing a Topic
// // ------------------

// var cmdVel = new ROSLIB.Topic({
//   ros : ros,
//   name : '/cmd_vel',
//   messageType : 'geometry_msgs/Twist'
// });

// var twist = new ROSLIB.Message({
//   linear : {
//     x : 0.1,
//     y : 0.2,
//     z : 0.3
//   },
//   angular : {
//     x : -0.1,
//     y : -0.2,
//     z : -0.3
//   }
// });
// cmdVel.publish(twist);

// Subscribing to a Topic
// ----------------------


function drawScan(msg){
  // Clear canvas
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Update map and draw line being made.
  // ctx.strokeStyle = 'rgba(82, 125, 232, 1)';
  // ctx.lineWidth = 2;
  for (let i = 0; i < msg.ranges.length; ++i) {
    const a = msg.angle_min + i * msg.angle_increment;
    const x = Math.cos(a) * msg.ranges[i];
    const y = Math.sin(a) * msg.ranges[i];
    drawPoint("#eb8334", x, y);
  }
  drawGrid();
}

function drawGrid() {
  const D = 50 * scale;
  const d = 2 * scale;
  ctx.strokeStyle = "#d1d1d1";
  ctx.beginPath();
  ctx.lineWidth = 1;
  for (let i = -D; i < D; i += d) {
    ctx.moveTo(i + origin.x, -D + origin.y);
    ctx.lineTo(i + origin.x, D + origin.y);
    ctx.moveTo(-D + origin.x, i + origin.y);
    ctx.lineTo(D + origin.x, i + origin.y);
  }
  ctx.stroke();

  ctx.lineWidth = 4;
  drawLine("#EF0000", 0, 0, 1.5, 0);
  drawLine("#00AF00", 0, 0, 0, 1.5);
}
  </script>
</body>
</html>