<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
</head>

<body>
  <h1>F1/10 Web Interface</h1>

  Car IP Address: <input type="text" id="ipaddr" value="localhost">
  <input type="button" onclick="connect()" value="Connect"><br>
  Status: <label id="status">Unknown</label><br>

  <script type="text/javascript" type="text/javascript">

    let socket = new WebSocket("ws://localhost:10272");

    class DataParser {
      constructor(arrayBuffer) {
        this.header = {
          num_particles: 0,
          num_path_options: 0,
          num_points: 0,
          num_lines: 0,
          num_arcs: 0,
          num_laser_rays: 0,
          laser_min_angle: 0,
          laser_max_angle: 0
        };
        this.length = arrayBuffer.byteLength;
        this.remainingBytes = this.length;
        this.dataView = new DataView(arrayBuffer, 0);
        this.offset = 0;
        this.littleEndian = true;
        // The first 4 bytes are the encoded number '42'. 
        // If the data is littleEndian the first byte should not be 0.
        if (arrayBuffer[0] === 0) {
          this.littleEndian = false;
        }
        this.offset += 4;
        this.remainingBytes -= 4;
      }

      readUint8() {
        let x = this.dataView.getUint8(this.offset, this.littleEndian);
        this.offset += 1;
        this.remainingBytes -= 1;
        return x;
      }

      readUint32() {
        let x = this.dataView.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        this.remainingBytes -= 4;
        return x;
      }

      readUint16() {
        let x = this.dataView.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        this.remainingBytes -= 2;
        return x;
      }

      readFloat32() {
        let x = this.dataView.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        this.remainingBytes -= 4;
        return x;
      }

      readHeader() {
        this.header.num_particles = this.readUint32();
        this.header.num_path_options = this.readUint32();
        this.header.num_points = this.readUint32();
        this.header.num_lines = this.readUint32();
        this.header.num_arcs = this.readUint32();
        this.header.num_laser_rays = this.readUint32();
        this.header.laser_min_angle = this.readFloat32();
        this.header.laser_max_angle = this.readFloat32();
        return this.header;
      }

      readPose() {
        let pose = {
          x: 0,
          y: 0,
          theta: 0
        };
        pose.x = this.readFloat32();
        pose.y = this.readFloat32();
        pose.z = this.readFloat32();
        return pose;
      }

      readPathVisualization() {
        let path = {
          curvature: 0,
          distance: 0,
          clearance: 0
        };
        path.curvature = this.readFloat32();
        path.distance = this.readFloat32();
        path.clearance = this.readFloat32();
        return path;
      }

      readMultiple(n, reader) {
        let arr = [];
        for (let i = 0; i < n; ++i) {
          arr.push(reader());
        }
        return arr;
      }

      readLaser() {
        let laser = {
          angle_min: this.header.laser_min_angle,
          angle_max: this.header.laser_max_angle,
          ranges: this.readMultiple(this.header.num_laser_rays, () => this.readUint16())
        }
        return laser;
      }

      readColor() {
        return '#' + (this.readUint32()).toString(16);
      }

      readPoint2D() {
        return {
          x: this.readFloat32(),
          y: this.readFloat32()
        };
      }

      readPoint() {
        return {
          point: this.readPoint2D(),
          color: this.readColor()
        };
      }

      readLine() {
        return {
          p0: this.readPoint2D(),
          p1: this.readPoint2D(),
          color: this.readColor()
        };
      }

      readArc() {
        return {
          center: this.readPoint2D(),
          radius: this.readFloat32(),
          start_angle: this.readFloat32(),
          end_angle: this.readFloat32(),
          color: this.readColor()
        };
      }

      readMessage() {
        let message = {
          header: this.readHeader(),
          laser: this.readLaser(),
          particles: this.readMultiple(this.header.num_particles, () => this.readPose()),
          path_options: this.readMultiple(this.header.num_path_options, () => this.readPathVisualization()),
          points: this.readMultiple(this.header.num_points, () => this.readPoint()),
          lines: this.readMultiple(this.header.num_lines, () => this.readLine()),
          arcs: this.readMultiple(this.header.num_arcs, () => this.readArc())
        }
        return message;
      }
    };

    function receiveData(d) {
      /*
      let littleEndian = true;
      if (d[0] === 0) {
        littleEndian = false;
      }
      console.log(`littleEndian: ${littleEndian}`);
      let view = new DataView(d);
      let len = d.byteLength;
      for (let offset = 0; offset + 4 <= len; offset += 4) {
        let x = view.getUint32(offset, littleEndian);
        console.log(x);
      }
      */
      let parser = new DataParser(d);
      let message = parser.readMessage();
      console.log(message);
      /*
      let header = parser.readHeader();
      console.log(header);
      for (let i = 0; i < header.num_particles; ++i) {
        console.log(parser.readPose());
      }
      for (let i = 0; i < header.num_path_options; ++i) {
        console.log(parser.readPathVisualization());
      }
      console.log("Laser:");
      console.log(parser.readLaser(header));
      */
    }
    socket.onopen = function (e) {
      console.log("[open] Connection established");
      console.log("Sending to server");
      socket.send("Ready.");
    };

    socket.onmessage = function (event) {
      console.log(`[message] Data received from server: ${event.data}`);
      console.log(event.data);
      new Response(event.data).arrayBuffer().then(
        receiveData);
    };

    socket.onclose = function (event) {
      if (event.wasClean) {
        console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
      } else {
        // e.g. server process killed or network down
        // event.code is usually 1006 in this case
        console.log('[close] Connection died');
      }
    };

    socket.onerror = function (error) {
      console.log(`[error] ${error.message}`);
    };
  </script>
